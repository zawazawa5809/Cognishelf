# Stable DiffusionÁâπÂåñÊ©üËÉΩ Ë©≥Á¥∞Ë®≠Ë®àÊõ∏

**‰ΩúÊàêÊó•:** 2025-01-08
**„Éê„Éº„Ç∏„Éß„É≥:** 1.0

## ÁõÆÊ¨°

1. [Ê¶ÇË¶Å](#Ê¶ÇË¶Å)
2. [„Éó„É≠„É≥„Éó„Éà„Éü„Ç≠„Çµ„Éº](#„Éó„É≠„É≥„Éó„Éà„Éü„Ç≠„Çµ„Éº)
3. [„Çπ„Çø„Ç§„É´„Éó„É™„Çª„ÉÉ„Éà](#„Çπ„Çø„Ç§„É´„Éó„É™„Çª„ÉÉ„Éà)
4. [„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº](#„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº)
5. [„Éó„É≠„É≥„Éó„ÉàÂàÜÊûê](#„Éó„É≠„É≥„Éó„ÉàÂàÜÊûê)
6. [„Éá„Éº„Çø„É¢„Éá„É´](#„Éá„Éº„Çø„É¢„Éá„É´)

---

## Ê¶ÇË¶Å

### Ë®≠Ë®àÊÄùÊÉ≥

**Stable DiffusionÁâπÊúâ„ÅÆ„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Å´ÊúÄÈÅ©Âåñ:**
- „Éó„É≠„É≥„Éó„Éà„ÅØ„ÄåÁµÑ„ÅøÂêà„Çè„Åõ„Äç„ÅåÈáçË¶Å
- „Éë„É©„É°„Éº„Çø„Å®„Éó„É≠„É≥„Éó„Éà„Çí„Çª„ÉÉ„Éà„ÅßÁÆ°ÁêÜ
- È´òÂìÅË≥™„Å™„Éó„É≠„É≥„Éó„Éà„ÇíÁ∞°Âçò„Å´ÂÜçÂà©Áî®
- „Éê„É™„Ç®„Éº„Ç∑„Éß„É≥„ÅÆ‰∏ÄÊã¨ÁîüÊàê

### Êó¢Â≠òÊ©üËÉΩ„Å®„ÅÆÈñ¢‰øÇ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Êó¢Â≠òÊ©üËÉΩ (Ê±éÁî®„Éó„É≠„É≥„Éó„ÉàÁÆ°ÁêÜ)        ‚îÇ
‚îÇ - „Éó„É≠„É≥„Éó„Éà‰øùÂ≠ò„ÉªÁ∑®ÈõÜ               ‚îÇ
‚îÇ - „Éï„Ç©„É´„ÉÄÁÆ°ÁêÜ                       ‚îÇ
‚îÇ - „Çø„Ç∞„ÉªÊ§úÁ¥¢                         ‚îÇ
‚îÇ - JSON„Ç®„ÇØ„Çπ„Éù„Éº„Éà                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚îÇ Êã°Âºµ
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SDÁâπÂåñÊ©üËÉΩ                           ‚îÇ
‚îÇ - „Éó„É≠„É≥„Éó„Éà„Éü„Ç≠„Çµ„Éº                 ‚îÇ
‚îÇ - „Çπ„Çø„Ç§„É´„Éó„É™„Çª„ÉÉ„Éà                 ‚îÇ
‚îÇ - „Éê„É™„Ç®„Éº„Ç∑„Éß„É≥ÁîüÊàê                 ‚îÇ
‚îÇ - „Éë„É©„É°„Éº„Çø‰øùÂ≠ò                     ‚îÇ
‚îÇ - „Éó„É≠„É≥„Éó„ÉàÂàÜÊûê                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## „Éó„É≠„É≥„Éó„Éà„Éü„Ç≠„Çµ„Éº

### ÁõÆÁöÑ
„Éó„É≠„É≥„Éó„Éà„Çí„É¨„Ç§„É§„ÉºÊßãÈÄ†„ÅßÁµÑ„ÅøÁ´ã„Å¶„ÄÅ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅßÁ∞°Âçò„Å´ÁµÑ„ÅøÂêà„Çè„Åõ„Çã

### UIÊßãÊàê

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ „Éó„É≠„É≥„Éó„Éà„Éü„Ç≠„Çµ„Éº                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                ‚îÇ
‚îÇ [„Éô„Éº„Çπ„Éó„É≠„É≥„Éó„Éà] (ÂøÖÈ†à)                      ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ cat sitting on a chair                 ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ     ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ [„Çπ„Çø„Ç§„É´„É¨„Ç§„É§„Éº]                             ‚îÇ
‚îÇ ‚òë „Ç¢„Éã„É°È¢®                                     ‚îÇ
‚îÇ   "anime style, cel shading, vibrant colors"  ‚îÇ
‚îÇ ‚òê ÂÜôÂÆüÁöÑ                                       ‚îÇ
‚îÇ   "photorealistic, photograph, 8k uhd"        ‚îÇ
‚îÇ ‚òê Ê≤πÁµµÈ¢®                                       ‚îÇ
‚îÇ   "oil painting, canvas texture"              ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ [ÂìÅË≥™„Éñ„Éº„Çπ„Çø„Éº]                               ‚îÇ
‚îÇ ‚òë 8KÈ´òÁîªË≥™                                     ‚îÇ
‚îÇ   "8k, ultra detailed, masterpiece"           ‚îÇ
‚îÇ ‚òë È´òÁ≤æÁ¥∞                                       ‚îÇ
‚îÇ   "highly detailed, sharp focus"              ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ [„Ç∑„Éº„É≥Ë¶ÅÁ¥†]                                   ‚îÇ
‚îÇ ‚òë „Éâ„É©„Éû„ÉÅ„ÉÉ„ÇØÁÖßÊòé                             ‚îÇ
‚îÇ   "dramatic lighting, cinematic"              ‚îÇ
‚îÇ ‚òê „Ç¥„Éº„É´„Éá„É≥„Ç¢„ÉØ„Éº                             ‚îÇ
‚îÇ   "golden hour, warm lighting"                ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ     ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ üì§ ÊúÄÁµÇ„Éó„É≠„É≥„Éó„Éà (45 tokens / 75):            ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ cat sitting on a chair, anime style,   ‚îÇ   ‚îÇ
‚îÇ ‚îÇ cel shading, vibrant colors, 8k, ultra ‚îÇ   ‚îÇ
‚îÇ ‚îÇ detailed, masterpiece, highly detailed,‚îÇ   ‚îÇ
‚îÇ ‚îÇ sharp focus, dramatic lighting,        ‚îÇ   ‚îÇ
‚îÇ ‚îÇ cinematic                              ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ üö´ „Éç„Ç¨„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„Éà:                       ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ realistic, photo, blurry, low quality  ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                ‚îÇ
‚îÇ [üíæ ‰øùÂ≠ò] [üìã „Ç≥„Éî„Éº] [üé≤ „É©„É≥„ÉÄ„É†]             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### „Éá„Éº„ÇøÊßãÈÄ†

#### „É¨„Ç§„É§„ÉºÂÆöÁæ©
```javascript
{
  id: "layer-anime-style",
  category: "„Çπ„Çø„Ç§„É´",  // „Çπ„Çø„Ç§„É´ | ÂìÅË≥™ | „Ç∑„Éº„É≥ | „Éç„Ç¨„ÉÜ„Ç£„Éñ
  name: "„Ç¢„Éã„É°È¢®",
  description: "„Çª„É´„Ç∑„Çß„Éº„Éá„Ç£„É≥„Ç∞„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë™ø",

  // „Éù„Ç∏„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„Éà„Å∏„ÅÆËøΩÂä†
  positiveAdd: "anime style, cel shading, vibrant colors",

  // „Éç„Ç¨„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„Éà„Å∏„ÅÆËøΩÂä†
  negativeAdd: "realistic, photo",

  // Â∞ÜÊù•„ÅÆÊã°ÂºµÁî®
  weight: 1.0,
  priority: 10,

  enabled: true,
  isDefault: false,
  createdAt: "2025-01-08T00:00:00.000Z"
}
```

#### „Éó„É≠„É≥„Éó„Éà‰øùÂ≠òÂΩ¢Âºè
```javascript
{
  id: "prompt-123",
  title: "„Ç¢„Éã„É°È¢®Áå´",

  // „Éü„Ç≠„Çµ„ÉºË®≠ÂÆö
  mixer: {
    base: "cat sitting on a chair",
    enabledLayers: [
      "layer-anime-style",
      "layer-8k",
      "layer-detailed",
      "layer-dramatic-light"
    ]
  },

  // ÊúÄÁµÇ„Éó„É≠„É≥„Éó„Éà(Ëá™ÂãïÁîüÊàê)
  sdConfig: {
    positivePrompt: "cat sitting on a chair, anime style, cel shading...",
    negativePrompt: "realistic, photo, blurry, low quality"
  }
}
```

### ÂÆüË£Ö„ÇØ„É©„Çπ

#### PromptMixer.js
```javascript
export class PromptMixer {
  constructor(basePrompt = "") {
    this.basePrompt = basePrompt;
    this.layers = [];
    this.negativeLayers = [];
  }

  addLayer(layer) {
    if (layer.category === '„Éç„Ç¨„ÉÜ„Ç£„Éñ') {
      this.negativeLayers.push(layer);
    } else {
      this.layers.push(layer);
    }
  }

  removeLayer(layerId) {
    this.layers = this.layers.filter(l => l.id !== layerId);
    this.negativeLayers = this.negativeLayers.filter(l => l.id !== layerId);
  }

  toggleLayer(layerId) {
    const layer = this.findLayer(layerId);
    if (layer) {
      layer.enabled = !layer.enabled;
    }
  }

  compile() {
    const positiveParts = [
      this.basePrompt.trim(),
      ...this.layers
        .filter(l => l.enabled)
        .sort((a, b) => (b.priority || 0) - (a.priority || 0))
        .map(l => l.positiveAdd)
    ].filter(s => s);

    const negativeParts = this.negativeLayers
      .filter(l => l.enabled)
      .map(l => l.negativeAdd)
      .filter(s => s);

    const positive = this.removeDuplicates(positiveParts).join(', ');
    const negative = this.removeDuplicates(negativeParts).join(', ');

    return {
      positive,
      negative,
      tokenCount: this.estimateTokens(positive),
      layerCount: this.layers.filter(l => l.enabled).length
    };
  }

  removeDuplicates(parts) {
    // „Ç´„É≥„ÉûÂå∫Âàá„Çä„Åß„Éà„Éº„ÇØ„É≥Âåñ„Åó„Å¶ÈáçË§áÂâäÈô§
    const tokens = parts
      .flatMap(p => p.split(',').map(t => t.trim()))
      .filter(t => t);
    return [...new Set(tokens)];
  }

  estimateTokens(text) {
    // CLIP tokenizer „ÅÆÁ∞°ÊòìÊé®ÂÆö
    // „Ç´„É≥„ÉûÂå∫Âàá„ÇäË¶ÅÁ¥†Êï∞ √ó 1.2ÂÄç
    const tokens = text.split(',').length;
    return Math.ceil(tokens * 1.2);
  }

  getUsageStats() {
    return {
      baseLength: this.basePrompt.length,
      layersEnabled: this.layers.filter(l => l.enabled).length,
      layersTotal: this.layers.length,
      negativeLayersEnabled: this.negativeLayers.filter(l => l.enabled).length
    };
  }

  // „Ç∑„É™„Ç¢„É©„Ç§„Ç∫
  toJSON() {
    return {
      base: this.basePrompt,
      layers: this.layers.map(l => ({
        id: l.id,
        enabled: l.enabled
      })),
      negativeLayers: this.negativeLayers.map(l => ({
        id: l.id,
        enabled: l.enabled
      }))
    };
  }

  // „Éá„Ç∑„É™„Ç¢„É©„Ç§„Ç∫
  static fromJSON(data, layerRegistry) {
    const mixer = new PromptMixer(data.base);

    data.layers.forEach(layerRef => {
      const layer = layerRegistry.findById(layerRef.id);
      if (layer) {
        layer.enabled = layerRef.enabled;
        mixer.addLayer(layer);
      }
    });

    data.negativeLayers.forEach(layerRef => {
      const layer = layerRegistry.findById(layerRef.id);
      if (layer) {
        layer.enabled = layerRef.enabled;
        mixer.negativeLayers.push(layer);
      }
    });

    return mixer;
  }

  findLayer(layerId) {
    return this.layers.find(l => l.id === layerId) ||
           this.negativeLayers.find(l => l.id === layerId);
  }
}
```

### „Éá„Éï„Ç©„É´„Éà„É¨„Ç§„É§„Éº„Çª„ÉÉ„Éà

#### data/default-layers.json
```json
{
  "styles": [
    {
      "name": "„Ç¢„Éã„É°È¢®",
      "category": "„Çπ„Çø„Ç§„É´",
      "positiveAdd": "anime style, cel shading, vibrant colors",
      "negativeAdd": "realistic, photo",
      "priority": 10
    },
    {
      "name": "ÂÜôÂÆüÁöÑ",
      "category": "„Çπ„Çø„Ç§„É´",
      "positiveAdd": "photorealistic, photograph, 8k uhd, dslr",
      "negativeAdd": "anime, cartoon, painting",
      "priority": 10
    },
    {
      "name": "Ê≤πÁµµÈ¢®",
      "category": "„Çπ„Çø„Ç§„É´",
      "positiveAdd": "oil painting, canvas texture, brush strokes",
      "negativeAdd": "digital art, smooth",
      "priority": 10
    }
  ],
  "quality": [
    {
      "name": "8KÈ´òÁîªË≥™",
      "category": "ÂìÅË≥™",
      "positiveAdd": "8k, ultra detailed, masterpiece",
      "negativeAdd": "low quality, blurry",
      "priority": 8
    },
    {
      "name": "È´òÁ≤æÁ¥∞",
      "category": "ÂìÅË≥™",
      "positiveAdd": "highly detailed, sharp focus, crisp",
      "negativeAdd": "soft focus, blurry",
      "priority": 8
    },
    {
      "name": "„Éó„É≠ÂìÅË≥™",
      "category": "ÂìÅË≥™",
      "positiveAdd": "professional, award-winning, best quality",
      "negativeAdd": "amateur, low quality",
      "priority": 7
    }
  ],
  "lighting": [
    {
      "name": "„Éâ„É©„Éû„ÉÅ„ÉÉ„ÇØ",
      "category": "„Ç∑„Éº„É≥",
      "positiveAdd": "dramatic lighting, cinematic, high contrast",
      "negativeAdd": "flat lighting",
      "priority": 5
    },
    {
      "name": "„ÇΩ„Éï„Éà„É©„Ç§„Éà",
      "category": "„Ç∑„Éº„É≥",
      "positiveAdd": "soft lighting, diffused, gentle",
      "negativeAdd": "harsh shadows",
      "priority": 5
    },
    {
      "name": "„Ç¥„Éº„É´„Éá„É≥„Ç¢„ÉØ„Éº",
      "category": "„Ç∑„Éº„É≥",
      "positiveAdd": "golden hour, warm lighting, sunset",
      "negativeAdd": "",
      "priority": 5
    }
  ],
  "negative": [
    {
      "name": "Ê®ôÊ∫ñNG",
      "category": "„Éç„Ç¨„ÉÜ„Ç£„Éñ",
      "positiveAdd": "",
      "negativeAdd": "blurry, low quality, watermark, text, signature, username",
      "priority": 0
    },
    {
      "name": "‰∫∫‰ΩìÂ¥©Â£äÈò≤Ê≠¢",
      "category": "„Éç„Ç¨„ÉÜ„Ç£„Éñ",
      "positiveAdd": "",
      "negativeAdd": "bad anatomy, extra limbs, missing limbs, bad hands, malformed hands",
      "priority": 0
    }
  ]
}
```

---

## „Çπ„Çø„Ç§„É´„Éó„É™„Çª„ÉÉ„Éà

### ÁõÆÁöÑ
È´òÂìÅË≥™„Å™„Éó„É≠„É≥„Éó„Éà„Çí„ÉØ„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅ©Áî®

### „Éá„Éº„ÇøÊßãÈÄ†

```javascript
{
  id: "preset-ghibli",
  name: "„Ç¢„Éã„É°È¢®(Ghibli)",
  category: "„Çπ„Çø„Ç§„É´",  // „Çπ„Çø„Ç§„É´ | „Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà | Áî®ÈÄî
  tags: ["„Ç¢„Éã„É°", "„Ç∏„Éñ„É™", "ÊâãÊèè„Åç"],

  description: "„Çπ„Çø„Ç∏„Ç™„Ç∏„Éñ„É™È¢®„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë™ø„ÄÇÊ∏©„Åã„Åø„ÅÆ„ÅÇ„ÇãËâ≤ÂΩ©„Å®ÊâãÊèè„ÅçÊÑü„ÄÇ",

  // „Éó„É™„Çª„ÉÉ„Éà„Éó„É≠„É≥„Éó„Éà
  positivePrompt: "studio ghibli style, anime, hand-drawn, traditional animation, cel shading, watercolor background, warm colors, nostalgic atmosphere",
  negativePrompt: "realistic, photo, 3d render, cgi, digital painting",

  // Êé®Â•®„Éë„É©„É°„Éº„Çø
  recommendedParams: {
    steps: 28,
    cfgScale: 7.0,
    sampler: "DPM++ 2M Karras",
    width: 768,
    height: 512,
    clipSkip: 2
  },

  // „Çµ„É≥„Éó„É´ÁîªÂÉè(Base64 or URL)
  preview: "data:image/jpeg;base64,/9j/4AAQSkZJRg...",

  // ‰ΩøÁî®Áµ±Ë®à
  usage: {
    applyCount: 124,
    rating: 4.8,
    lastUsed: "2025-01-08T14:23:00.000Z"
  },

  createdAt: "2025-01-08T00:00:00.000Z",
  updatedAt: "2025-01-08T00:00:00.000Z",
  author: "system"  // system | user
}
```

### „Éó„É™„Çª„ÉÉ„Éà„Ç´„ÉÜ„Ç¥„É™

#### 1. „Çπ„Çø„Ç§„É´Âà•
- „Ç¢„Éã„É°È¢®(Ghibli)
- „Ç¢„Éã„É°È¢®(Makoto Shinkai)
- „Éï„Ç©„Éà„É™„Ç¢„É´
- „Çµ„Ç§„Éê„Éº„Éë„É≥„ÇØ
- „Éï„Ç°„É≥„Çø„Ç∏„Éº
- Ê≤πÁµµÈ¢®
- Ê∞¥ÂΩ©È¢®
- „Éö„É≥Áîª„ÉªÁ∑öÁîª

#### 2. „Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÂà•
- Greg RutkowskiÈ¢®
- ArtgermÈ¢®
- Ross TranÈ¢®
- WLOPÈ¢®
- Ilya KuvshinovÈ¢®

#### 3. Áî®ÈÄîÂà•
- „Ç≠„É£„É©„ÇØ„Çø„Éº„Éá„Ç∂„Ç§„É≥
- ËÉåÊôØ„ÉªÈ¢®ÊôØ
- „Ç≥„É≥„Çª„Éó„Éà„Ç¢„Éº„Éà
- „Éù„Éº„Éà„É¨„Éº„Éà
- „Ç¢„Ç§„Ç≥„É≥„Éª„Ç¢„Éê„Çø„Éº
- „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®

### ÂÆüË£Ö„ÇØ„É©„Çπ

#### StylePresetManager.js
```javascript
export class StylePresetManager {
  constructor(presetsManager, promptsManager) {
    this.presetsManager = presetsManager;
    this.promptsManager = promptsManager;
  }

  async applyToPrompt(presetId, targetPromptId) {
    const preset = await this.presetsManager.findById(presetId);
    const prompt = await this.promptsManager.findById(targetPromptId);

    if (!preset || !prompt) {
      throw new Error('Preset or Prompt not found');
    }

    // „Éó„É≠„É≥„Éó„Éà„Éû„Éº„Ç∏
    const updatedPrompt = {
      ...prompt,
      sdConfig: {
        ...prompt.sdConfig,
        positivePrompt: this.mergePrompts(
          prompt.sdConfig.positivePrompt,
          preset.positivePrompt
        ),
        negativePrompt: this.mergePrompts(
          prompt.sdConfig.negativePrompt,
          preset.negativePrompt
        ),
        parameters: {
          ...prompt.sdConfig.parameters,
          ...preset.recommendedParams
        },
        stylePresets: [
          ...(prompt.sdConfig.stylePresets || []),
          presetId
        ]
      }
    };

    await this.promptsManager.update(targetPromptId, updatedPrompt);

    // ‰ΩøÁî®Áµ±Ë®àÊõ¥Êñ∞
    await this.updateUsageStats(presetId);

    return updatedPrompt;
  }

  mergePrompts(base, addition) {
    // „Éà„Éº„ÇØ„É≥„ÇíÈáçË§áÊéíÈô§„Åó„Å¶„Éû„Éº„Ç∏
    const baseTokens = this.tokenize(base);
    const addTokens = this.tokenize(addition);

    const merged = [...new Set([...baseTokens, ...addTokens])];
    return merged.filter(s => s).join(', ');
  }

  tokenize(prompt) {
    return prompt
      .split(',')
      .map(s => s.trim())
      .filter(s => s);
  }

  async updateUsageStats(presetId) {
    const preset = await this.presetsManager.findById(presetId);

    preset.usage.applyCount += 1;
    preset.usage.lastUsed = new Date().toISOString();

    await this.presetsManager.update(presetId, preset);
  }

  async createCustomPreset(data) {
    const preset = {
      name: data.name,
      category: data.category || '„Ç´„Çπ„Çø„É†',
      tags: data.tags || [],
      description: data.description || '',
      positivePrompt: data.positivePrompt,
      negativePrompt: data.negativePrompt || '',
      recommendedParams: data.recommendedParams || {},
      preview: data.preview || '',
      usage: {
        applyCount: 0,
        rating: 0,
        lastUsed: null
      },
      author: 'user'
    };

    return await this.presetsManager.add(preset);
  }

  async ratePreset(presetId, rating) {
    const preset = await this.presetsManager.findById(presetId);

    // Á∞°ÊòìÁöÑ„Å™Âπ≥ÂùáË©ï‰æ°Ë®àÁÆó
    const totalRatings = preset.usage.applyCount;
    const currentRating = preset.usage.rating || 0;

    const newRating = (currentRating * totalRatings + rating) / (totalRatings + 1);

    preset.usage.rating = newRating;

    await this.presetsManager.update(presetId, preset);

    return newRating;
  }
}
```

---

## „Éê„É™„Ç®„Éº„Ç∑„Éß„É≥„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº

### ÁõÆÁöÑ
„ÉÜ„É≥„Éó„É¨„Éº„ÉàÂ§âÊï∞„ÅßË§áÊï∞„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥„Çí‰∏ÄÊã¨ÁîüÊàê

### Â§âÊï∞Ë®òÊ≥ï

```
{{variable_name}}
```

### ‰ΩøÁî®‰æã

#### Âü∫Êú¨ÁöÑ„Å™‰æã
```javascript
// „ÉÜ„É≥„Éó„É¨„Éº„Éà
"{{subject}} {{action}}, {{time}}, {{style}}, 8k"

// Â§âÊï∞ÂÆöÁæ©
{
  subject: ["cat", "dog", "bird"],
  action: ["sitting", "running", "flying"],
  time: ["sunrise", "sunset", "night"],
  style: ["anime", "realistic"]
}

// ÁîüÊàêÁµêÊûú: 3 √ó 3 √ó 3 √ó 2 = 54 „Éë„Çø„Éº„É≥
[
  "cat sitting, sunrise, anime, 8k",
  "cat sitting, sunset, anime, 8k",
  "cat sitting, night, anime, 8k",
  // ... (ÂÖ®54„Éë„Çø„Éº„É≥)
]
```

#### È´òÂ∫¶„Å™‰æã(Êù°‰ª∂‰ªò„ÅçÂ§âÊï∞)
```javascript
{
  style: ["anime", "realistic"],
  quality: {
    "anime": "8k, cel shading, vibrant",
    "realistic": "8k, photorealistic, sharp"
  }
}

// style="anime" „ÅÆÂ†¥Âêà ‚Üí quality="8k, cel shading, vibrant"
// style="realistic" „ÅÆÂ†¥Âêà ‚Üí quality="8k, photorealistic, sharp"
```

### „Éá„Éº„ÇøÊßãÈÄ†

```javascript
{
  id: "variation-template-123",
  name: "ÂãïÁâ©„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥",

  template: "{{subject}} {{action}}, {{time}}, {{style}}, 8k, masterpiece",

  variables: {
    subject: {
      type: "list",
      values: ["cat", "dog", "bird", "rabbit"]
    },
    action: {
      type: "list",
      values: ["sitting", "running", "flying", "sleeping"]
    },
    time: {
      type: "list",
      values: ["sunrise", "sunset", "night", "midday"]
    },
    style: {
      type: "list",
      values: ["anime", "realistic", "oil painting"]
    }
  },

  generationSettings: {
    mode: "all",  // all | random | weighted
    maxVariations: 100,
    randomSeed: null
  },

  baseConfig: {
    negativePrompt: "blurry, low quality",
    parameters: {
      steps: 28,
      cfgScale: 7.5,
      sampler: "DPM++ 2M Karras"
    }
  },

  createdAt: "2025-01-08T00:00:00.000Z"
}
```

### ÂÆüË£Ö„ÇØ„É©„Çπ

#### VariationGenerator.js
```javascript
export class VariationGenerator {
  constructor(template, variables) {
    this.template = template;
    this.variables = variables;
  }

  generateAll() {
    const variableKeys = Object.keys(this.variables);
    const variableValues = variableKeys.map(key => {
      const varDef = this.variables[key];

      if (varDef.type === 'list') {
        return varDef.values;
      } else if (varDef.type === 'conditional') {
        // Êù°‰ª∂‰ªò„ÅçÂ§âÊï∞„ÅÆÂá¶ÁêÜ
        return Object.keys(varDef.mapping);
      }
    });

    const combinations = this.cartesianProduct(variableValues);

    return combinations.map((combo, index) => {
      return this.resolveTemplate(combo, variableKeys, index);
    });
  }

  cartesianProduct(arrays) {
    return arrays.reduce(
      (acc, curr) => acc.flatMap(x => curr.map(y => [...x, y])),
      [[]]
    );
  }

  resolveTemplate(values, keys, index) {
    let prompt = this.template;
    const variableMap = {};

    keys.forEach((key, i) => {
      const value = values[i];
      variableMap[key] = value;

      // ÂçòÁ¥îÁΩÆÊèõ
      prompt = prompt.replace(
        new RegExp(`{{${key}}}`, 'g'),
        value
      );
    });

    // Êù°‰ª∂‰ªò„ÅçÂ§âÊï∞„ÅÆËß£Ê±∫
    keys.forEach(key => {
      const varDef = this.variables[key];
      if (varDef.type === 'conditional') {
        const dependsOn = varDef.dependsOn;
        const conditionValue = variableMap[dependsOn];
        const resolvedValue = varDef.mapping[conditionValue];

        if (resolvedValue) {
          prompt = prompt.replace(
            new RegExp(`{{${key}}}`, 'g'),
            resolvedValue
          );
        }
      }
    });

    return {
      id: `variation-${index}`,
      prompt,
      variables: variableMap
    };
  }

  generateRandom(count) {
    const all = this.generateAll();

    if (all.length <= count) {
      return all;
    }

    // „É©„É≥„ÉÄ„É†„Çµ„É≥„Éó„É™„É≥„Ç∞
    const shuffled = all.sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
  }

  async saveAsPrompts(variations, baseConfig, promptsManager) {
    const saved = [];

    for (const variation of variations) {
      const prompt = {
        title: this.generateTitle(variation),
        content: variation.prompt,
        tags: ["„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥"],
        sdConfig: {
          positivePrompt: variation.prompt,
          negativePrompt: baseConfig.negativePrompt || '',
          parameters: baseConfig.parameters || {},
          stylePresets: [],
          variations: [],
          stats: {
            generationCount: 0,
            lastUsed: null,
            rating: 0
          }
        }
      };

      const savedPrompt = await promptsManager.add(prompt);
      saved.push(savedPrompt);
    }

    return saved;
  }

  generateTitle(variation) {
    const values = Object.values(variation.variables);
    return values.join(' - ');
  }

  estimateTotalVariations() {
    const counts = Object.keys(this.variables).map(key => {
      const varDef = this.variables[key];
      if (varDef.type === 'list') {
        return varDef.values.length;
      } else if (varDef.type === 'conditional') {
        return Object.keys(varDef.mapping).length;
      }
      return 1;
    });

    return counts.reduce((a, b) => a * b, 1);
  }
}
```

---

## „Éó„É≠„É≥„Éó„ÉàÂàÜÊûê

### ÁõÆÁöÑ
„Éó„É≠„É≥„Éó„Éà„ÅÆÂìÅË≥™„ÇíËá™ÂãïÂàÜÊûê„Åó„ÄÅÊîπÂñÑÊèêÊ°à„ÇíÊèêÁ§∫

### ÂàÜÊûêÈ†ÖÁõÆ

#### 1. ÊõñÊòß„Å™ÂçòË™ûÊ§úÂá∫
```javascript
const VAGUE_WORDS = [
  'beautiful', 'nice', 'good', 'amazing', 'great',
  'cool', 'awesome', 'perfect', 'wonderful'
];
```

#### 2. „Çπ„Çø„Ç§„É´ÊåáÂÆö„ÉÅ„Çß„ÉÉ„ÇØ
```javascript
const STYLE_KEYWORDS = [
  'anime', 'realistic', 'photorealistic', 'photograph',
  'oil painting', 'watercolor', 'digital art', 'sketch'
];
```

#### 3. ÂìÅË≥™„Ç≠„Éº„ÉØ„Éº„ÉâÂÖÖË∂≥Â∫¶
```javascript
const QUALITY_KEYWORDS = [
  '8k', '4k', 'uhd', 'masterpiece', 'best quality',
  'highly detailed', 'ultra detailed', 'sharp focus',
  'professional', 'award-winning'
];
```

#### 4. „Éà„Éº„ÇØ„É≥‰ΩøÁî®Áéá
- CLIP tokenizer: ÊúÄÂ§ß75„Éà„Éº„ÇØ„É≥
- Êé®Â•®: 60„Éà„Éº„ÇØ„É≥‰ª•‰∏ã(‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„Çã)

#### 5. „Éç„Ç¨„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„ÉàÊé®Â•®
```javascript
const RECOMMENDED_NEGATIVES = {
  'anime': ['realistic', 'photo', '3d render'],
  'realistic': ['anime', 'cartoon', 'painting'],
  'oil painting': ['digital art', 'smooth', 'clean']
};
```

### „Éá„Éº„ÇøÊßãÈÄ†(ÂàÜÊûêÁµêÊûú)

```javascript
{
  prompt: "cat sitting, beautiful, nice quality",

  analysis: {
    warnings: [
      {
        type: 'vague-word',
        word: 'beautiful',
        position: 13,
        message: '"beautiful" „ÅØÊäΩË±°ÁöÑ„ÄÇÂÖ∑‰ΩìÁöÑ„Å™Ë°®Áèæ„ÇíÊé®Â•®',
        suggestions: ['highly detailed', 'intricate design', 'elegant composition']
      },
      {
        type: 'vague-word',
        word: 'nice',
        position: 25,
        message: '"nice" „ÅØÊäΩË±°ÁöÑ„ÄÇÂÖ∑‰ΩìÁöÑ„Å™Ë°®Áèæ„ÇíÊé®Â•®',
        suggestions: ['well-composed', 'harmonious colors']
      }
    ],

    suggestions: [
      {
        type: 'missing-style',
        message: '„Çπ„Çø„Ç§„É´ÊåáÂÆö„Åå„ÅÇ„Çä„Åæ„Åõ„Çì',
        options: ['anime style', 'photorealistic', 'oil painting', 'watercolor']
      },
      {
        type: 'quality-boost',
        message: 'ÂìÅË≥™„Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆËøΩÂä†„ÇíÊé®Â•®',
        keywords: ['8k', 'masterpiece', 'sharp focus', 'professional']
      },
      {
        type: 'negative-recommendation',
        message: '„Éç„Ç¨„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„Éà„ÅÆËøΩÂä†„ÇíÊé®Â•®',
        keywords: ['blurry', 'low quality', 'watermark', 'text']
      }
    ],

    stats: {
      tokens: 12,
      tokenUsage: 16,  // 12/75 = 16%
      characterCount: 35,
      wordCount: 5,
      qualityKeywords: 0,
      styleSpecified: false
    },

    score: 3.5,  // 10ÁÇπÊ∫ÄÁÇπ
    grade: 'C'   // S, A, B, C, D
  },

  optimized: "cat sitting, highly detailed, intricate fur texture, photorealistic, 8k, masterpiece, sharp focus",

  improvements: [
    { from: 'beautiful', to: 'highly detailed' },
    { from: 'nice quality', to: 'photorealistic, 8k, masterpiece, sharp focus' },
    { added: 'intricate fur texture' }
  ]
}
```

### ÂÆüË£Ö„ÇØ„É©„Çπ

#### PromptAnalyzer.js
```javascript
export class PromptAnalyzer {
  constructor() {
    this.vagueWords = new Set([
      'beautiful', 'nice', 'good', 'amazing', 'great',
      'cool', 'awesome', 'perfect', 'wonderful'
    ]);

    this.styleKeywords = new Set([
      'anime', 'realistic', 'photorealistic', 'photograph',
      'oil painting', 'watercolor', 'digital art', 'sketch',
      'concept art', 'illustration'
    ]);

    this.qualityKeywords = new Set([
      '8k', '4k', 'uhd', 'hd', 'masterpiece', 'best quality',
      'highly detailed', 'ultra detailed', 'sharp focus',
      'professional', 'award-winning', 'trending'
    ]);
  }

  analyze(prompt) {
    const warnings = this.detectWarnings(prompt);
    const suggestions = this.generateSuggestions(prompt);
    const stats = this.calculateStats(prompt);
    const score = this.calculateScore(warnings, suggestions, stats);

    return {
      prompt,
      analysis: {
        warnings,
        suggestions,
        stats,
        score,
        grade: this.scoreToGrade(score)
      },
      optimized: this.generateOptimizedPrompt(prompt, warnings, suggestions),
      improvements: this.generateImprovements(prompt, warnings, suggestions)
    };
  }

  detectWarnings(prompt) {
    const warnings = [];
    const lowerPrompt = prompt.toLowerCase();

    // ÊõñÊòß„Å™ÂçòË™ûÊ§úÂá∫
    this.vagueWords.forEach(word => {
      const regex = new RegExp(`\\b${word}\\b`, 'gi');
      const match = regex.exec(prompt);

      if (match) {
        warnings.push({
          type: 'vague-word',
          word,
          position: match.index,
          message: `"${word}" „ÅØÊäΩË±°ÁöÑ„ÄÇÂÖ∑‰ΩìÁöÑ„Å™Ë°®Áèæ„ÇíÊé®Â•®`,
          suggestions: this.getReplacementSuggestions(word)
        });
      }
    });

    return warnings;
  }

  generateSuggestions(prompt) {
    const suggestions = [];
    const lowerPrompt = prompt.toLowerCase();

    // „Çπ„Çø„Ç§„É´Êú™ÊåáÂÆö
    const hasStyle = Array.from(this.styleKeywords).some(
      style => lowerPrompt.includes(style)
    );

    if (!hasStyle) {
      suggestions.push({
        type: 'missing-style',
        message: '„Çπ„Çø„Ç§„É´ÊåáÂÆö„Åå„ÅÇ„Çä„Åæ„Åõ„Çì',
        options: ['anime style', 'photorealistic', 'oil painting', 'watercolor']
      });
    }

    // ÂìÅË≥™„Ç≠„Éº„ÉØ„Éº„Éâ‰∏çË∂≥
    const foundQuality = Array.from(this.qualityKeywords).filter(
      kw => lowerPrompt.includes(kw)
    );

    if (foundQuality.length < 2) {
      const remainingKeywords = Array.from(this.qualityKeywords).filter(
        kw => !foundQuality.includes(kw)
      );

      suggestions.push({
        type: 'quality-boost',
        message: 'ÂìÅË≥™„Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆËøΩÂä†„ÇíÊé®Â•®',
        keywords: remainingKeywords.slice(0, 5)
      });
    }

    // „Éç„Ç¨„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„ÉàÊé®Â•®
    suggestions.push({
      type: 'negative-recommendation',
      message: '„Éç„Ç¨„ÉÜ„Ç£„Éñ„Éó„É≠„É≥„Éó„Éà„ÅÆËøΩÂä†„ÇíÊé®Â•®',
      keywords: ['blurry', 'low quality', 'watermark', 'text', 'signature']
    });

    return suggestions;
  }

  calculateStats(prompt) {
    const tokens = this.estimateTokens(prompt);
    const words = prompt.split(/\s+/).length;
    const chars = prompt.length;

    const qualityCount = Array.from(this.qualityKeywords).filter(
      kw => prompt.toLowerCase().includes(kw)
    ).length;

    const styleSpecified = Array.from(this.styleKeywords).some(
      style => prompt.toLowerCase().includes(style)
    );

    return {
      tokens,
      tokenUsage: Math.round((tokens / 75) * 100),
      characterCount: chars,
      wordCount: words,
      qualityKeywords: qualityCount,
      styleSpecified
    };
  }

  estimateTokens(text) {
    // CLIP tokenizer „ÅÆÁ∞°ÊòìÊé®ÂÆö
    // „Ç´„É≥„ÉûÂå∫Âàá„ÇäË¶ÅÁ¥†Êï∞ √ó 1.2ÂÄç
    const tokens = text.split(',').length;
    return Math.ceil(tokens * 1.2);
  }

  calculateScore(warnings, suggestions, stats) {
    let score = 10;

    // Ë≠¶Âëä„Å´„Çà„Çã„Éö„Éä„É´„ÉÜ„Ç£
    score -= warnings.length * 0.5;

    // ÊèêÊ°à„Å´„Çà„Çã„Éö„Éä„É´„ÉÜ„Ç£
    score -= suggestions.length * 0.3;

    // „Éà„Éº„ÇØ„É≥‰ΩøÁî®Áéá„Éú„Éº„Éä„Çπ
    if (stats.tokenUsage > 80) {
      score -= 1;  // ‰Ωø„ÅÑ„Åô„Åé
    } else if (stats.tokenUsage < 30) {
      score -= 0.5;  // Â∞ë„Å™„Åô„Åé
    }

    return Math.max(0, Math.min(10, score));
  }

  scoreToGrade(score) {
    if (score >= 9) return 'S';
    if (score >= 7) return 'A';
    if (score >= 5) return 'B';
    if (score >= 3) return 'C';
    return 'D';
  }

  generateOptimizedPrompt(prompt, warnings, suggestions) {
    let optimized = prompt;

    // ÊõñÊòß„Å™ÂçòË™û„ÇíÁΩÆÊèõ
    warnings.forEach(warning => {
      if (warning.type === 'vague-word' && warning.suggestions.length > 0) {
        optimized = optimized.replace(
          new RegExp(`\\b${warning.word}\\b`, 'gi'),
          warning.suggestions[0]
        );
      }
    });

    // ÂìÅË≥™„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíËøΩÂä†
    const qualitySuggestion = suggestions.find(s => s.type === 'quality-boost');
    if (qualitySuggestion && qualitySuggestion.keywords.length > 0) {
      optimized += ', ' + qualitySuggestion.keywords.slice(0, 3).join(', ');
    }

    return optimized;
  }

  generateImprovements(prompt, warnings, suggestions) {
    const improvements = [];

    warnings.forEach(warning => {
      if (warning.type === 'vague-word' && warning.suggestions.length > 0) {
        improvements.push({
          from: warning.word,
          to: warning.suggestions[0]
        });
      }
    });

    suggestions.forEach(suggestion => {
      if (suggestion.type === 'quality-boost') {
        improvements.push({
          added: suggestion.keywords.slice(0, 3).join(', ')
        });
      }
    });

    return improvements;
  }

  getReplacementSuggestions(vagueWord) {
    const replacements = {
      'beautiful': ['highly detailed', 'intricate design', 'elegant composition'],
      'nice': ['well-composed', 'harmonious colors', 'balanced'],
      'good': ['high quality', 'professional grade', 'well-executed'],
      'amazing': ['stunning', 'breathtaking', 'extraordinary detail'],
      'great': ['exceptional', 'outstanding quality', 'masterful']
    };

    return replacements[vagueWord.toLowerCase()] || ['detailed', 'high quality'];
  }
}
```

---

## „Éá„Éº„Çø„É¢„Éá„É´

### IndexedDB Schema v2

```javascript
const DB_NAME = 'cognishelf-db';
const DB_VERSION = 2;

const schema = {
  prompts: {
    keyPath: 'id',
    indexes: [
      { name: 'title', keyPath: 'title', unique: false },
      { name: 'createdAt', keyPath: 'createdAt', unique: false },
      { name: 'tags', keyPath: 'tags', unique: false, multiEntry: true },
      { name: 'folder', keyPath: 'folder', unique: false }
    ]
  },

  contexts: {
    keyPath: 'id',
    indexes: [
      { name: 'title', keyPath: 'title', unique: false },
      { name: 'createdAt', keyPath: 'createdAt', unique: false },
      { name: 'category', keyPath: 'category', unique: false },
      { name: 'folder', keyPath: 'folder', unique: false }
    ]
  },

  folders: {
    keyPath: 'id',
    indexes: [
      { name: 'name', keyPath: 'name', unique: false },
      { name: 'type', keyPath: 'type', unique: false }
    ]
  },

  // Êñ∞Ë¶èËøΩÂä† (v2)
  stylePresets: {
    keyPath: 'id',
    indexes: [
      { name: 'name', keyPath: 'name', unique: false },
      { name: 'category', keyPath: 'category', unique: false },
      { name: 'tags', keyPath: 'tags', unique: false, multiEntry: true },
      { name: 'rating', keyPath: 'usage.rating', unique: false }
    ]
  },

  promptLayers: {
    keyPath: 'id',
    indexes: [
      { name: 'category', keyPath: 'category', unique: false },
      { name: 'name', keyPath: 'name', unique: false }
    ]
  },

  variationTemplates: {
    keyPath: 'id',
    indexes: [
      { name: 'name', keyPath: 'name', unique: false },
      { name: 'createdAt', keyPath: 'createdAt', unique: false }
    ]
  }
};
```

### „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„É≠„Ç∏„ÉÉ„ÇØ

```javascript
async function upgradeDatabase(db, oldVersion, newVersion, transaction) {
  if (oldVersion < 2) {
    // „Éó„É≠„É≥„Éó„Éà„Å´sdConfig„Éï„Ç£„Éº„É´„ÉâËøΩÂä†
    const promptStore = transaction.objectStore('prompts');
    const allPrompts = await promptStore.getAll();

    for (const prompt of allPrompts) {
      if (!prompt.sdConfig) {
        prompt.sdConfig = {
          positivePrompt: prompt.content,
          negativePrompt: '',
          parameters: {
            steps: 28,
            cfgScale: 7.5,
            sampler: 'DPM++ 2M Karras',
            width: 512,
            height: 512,
            seed: -1
          },
          stylePresets: [],
          variations: [],
          stats: {
            generationCount: 0,
            lastUsed: null,
            rating: 0
          }
        };

        await promptStore.put(prompt);
      }
    }

    // Êñ∞Ë¶è„Çπ„Éà„Ç¢ËøΩÂä†
    if (!db.objectStoreNames.contains('stylePresets')) {
      const presetStore = db.createObjectStore('stylePresets', { keyPath: 'id' });
      presetStore.createIndex('name', 'name', { unique: false });
      presetStore.createIndex('category', 'category', { unique: false });
      presetStore.createIndex('tags', 'tags', { unique: false, multiEntry: true });
      presetStore.createIndex('rating', 'usage.rating', { unique: false });
    }

    if (!db.objectStoreNames.contains('promptLayers')) {
      const layerStore = db.createObjectStore('promptLayers', { keyPath: 'id' });
      layerStore.createIndex('category', 'category', { unique: false });
      layerStore.createIndex('name', 'name', { unique: false });
    }

    if (!db.objectStoreNames.contains('variationTemplates')) {
      const templateStore = db.createObjectStore('variationTemplates', { keyPath: 'id' });
      templateStore.createIndex('name', 'name', { unique: false });
      templateStore.createIndex('createdAt', 'createdAt', { unique: false });
    }
  }
}
```

---

## „Åæ„Å®„ÇÅ

### ÂÆüË£ÖÂÑ™ÂÖàÂ∫¶

| Phase | Ê©üËÉΩ | ÂÑ™ÂÖàÂ∫¶ | Â∑•Êï∞ | „Éì„Ç∏„Éç„Çπ‰æ°ÂÄ§ |
|-------|------|--------|------|-------------|
| 0 | ViteÁßªË°å | üî• P0 | 1ÈÄ±Èñì | ÈñãÁô∫ÂäπÁéáÂåñ |
| 1 | SDÂü∫Áõ§ | üî• P0 | 3Êó• | „Éá„Éº„ÇøÁÆ°ÁêÜÂü∫Áõ§ |
| 2 | „Éó„É≠„É≥„Éó„Éà„Éü„Ç≠„Çµ„Éº | ‚≠ê P1 | 1ÈÄ±Èñì | UXÂêë‰∏ä(ÊúÄÂ§ß) |
| 3 | „Çπ„Çø„Ç§„É´„Éó„É™„Çª„ÉÉ„Éà | ‚≠ê P1 | 3Êó• | Âç≥Êà¶Âäõ |
| 4 | „Éê„É™„Ç®„Éº„Ç∑„Éß„É≥ÁîüÊàê | üí° P2 | 1ÈÄ±Èñì | ÂäπÁéáÂåñ |
| 5 | „Éó„É≠„É≥„Éó„ÉàÂàÜÊûê | üí° P2 | 1ÈÄ±Èñì | Â≠¶ÁøíÊîØÊè¥ |

### Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó

1. **ROADMAP„Éâ„Ç≠„É•„É°„É≥„ÉàÁ¢∫Ë™ç**
2. **Phase 0ÁùÄÊâãÊ∫ñÂÇô**
3. **ViteÁí∞Â¢ÉÊßãÁØâ**
4. **„É¢„Ç∏„É•„Éº„É´ÂàÜÂâ≤ÂÆüË£Ö**

---

**ÊúÄÁµÇÊõ¥Êñ∞:** 2025-01-08
**„É¨„Éì„É•„Éº:** Êú™ÂÆüÊñΩ
